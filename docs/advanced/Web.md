＃Web客户端

Oauth最初是为与Web客户端合作而设计的，因此对于大多数开发人员来说，该过程应该相当平稳。 但是，有些用例很棘手，尽管并非不可能使用。


##分布式或多域客户

对于具有多个域的客户端（例如多站点WordPress安装）的一个问题是回调：客户端只能具有单个注册回调，而大多数URL中都没有变化。 这可能会使多个领域的工作变得棘手。

可以通过在回调URL中添加额外的查询参数来轻松处理，因为这些**可以按要求设置。 然后可以通过您的回调URL来处理这些，以传递到辅助回调。

例如，对于WordPress多站点，将回调URL设置为主站点上的URL。 然后，可以在设置请求回调时添加``site = {id}```site = {id}'。 然后，回调可以基于此参数将用户的浏览器重定向到每个站点回调（确保沿`oauth_token`和oauth_verifier`参数传递。）。

**注意：**使用此方法时，请确保验证该站点。 检查要处理的请求令牌是否实际上是由网站询问的。 如果您使用域而不是站点ID，请 *非常 *小心不要重定向到未知域。 未能检查这很容易导致CSRF（网络钓鱼）攻击。


##浏览器客户端

该应用程序越来越多地基于现代JavaScript应用程序，可以完全在用户的浏览器中运行。 OAuth 1（不幸的是）不是为此用例设计的。 Oauth 2对纠正此问题有很长的路要走，但是如前所述，[我们无法使用它：（](../ resives/oauth-1.md)

这主要归结为应用程序的秘密。 OAuth 1.0A依靠客户秘密为秘密（DUH）作为授权流的基础。 这是签名过程的核心。 如果没有这个秘密，其他应用程序可以将自己的令牌作为您的应用程序发行。 Oauth 2为具有“隐式”流的公共秘密的客户提供津贴。

处理此问题的最简单方法是引入最小的服务器端组件。 可以从头开始创建这一点，也可以使用[Guardian](http://guardianjs.com/)等预制服务器。


##最佳实践

*切勿暴露秘密，例如在JS客户端应用程序中。 而是使用代理来处理OAuth身份验证。
*同样，切勿将验证者暴露于控制外的站点。 验证者是专门用于缓解CSRF的，因此在将其传递到另一个URL之前，请格外小心。
